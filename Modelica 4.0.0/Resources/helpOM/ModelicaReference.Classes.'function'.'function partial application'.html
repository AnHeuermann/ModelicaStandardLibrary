<?xml version="1.0"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="HTML Tidy for HTML5 for Linux version 5.6.0" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<title>ModelicaReference.Classes.'function'.'function partial
application'</title>
</head>
<body>
<h1><a class="omc-h1-a" href="index.html">.</a><a class="omc-h1-a" href="ModelicaReference.html">ModelicaReference</a>.<a class="omc-h1-a" href="ModelicaReference.Classes.html">Classes</a>.<a class="omc-h1-a" href="ModelicaReference.Classes.%27function%27.html">'function'</a>.<span class="omc-h1">'function
partial application'</span></h1>
<h2><a id="info" name="info">Information</a></h2>
<p>A function partial application is a function call with certain
formal parameters bound to expressions. A function partial
application returns a partially evaluated function that is also a
function, with the remaining not bound formal parameters still
present in the same order as in the original function declaration.
A function partial application is specified by the function keyword
followed by a function call to func_name giving named formal
parameter associations for the formal parameters to be bound,
e.g.:</p>
<blockquote>
<pre>
<strong>function</strong> func_name(..., formal_parameter_name = expr, ...)
</pre></blockquote>
<p>[<em>Note that the keyword function in a function partial
application differentiates the syntax from a normal function call
where some parameters have been left out, and instead supplied via
default values.</em>] The function created by the function partial
application acts as the original function but with the bound formal
input parameters(s) removed, i.e., they cannot be supplied
arguments at function call. The binding occurs when the partially
evaluated function is created. A partially evaluated function is
"function compatible" to the same function where all bound
arguments are removed [<em>thus, for checking function type
compatibility, bound formal parameters are ignored</em>].</p>
<p>Example of function partial application as argument, positional
argument passing, according to case (b) above:</p>
<blockquote>
<pre>
<strong>model</strong> Test
   <strong>parameter</strong> Integer N;
   Real area;
<strong>algorithm</strong>
   area := 0;
   <strong>for</strong> i <strong>in</strong> 1:N <strong>loop</strong>
     area  := area + quadrature(0, 1, <strong>function</strong> Sine(A=2, w=i*time));
   <strong>end for</strong>;
<strong>end</strong> Test;

<strong>function</strong> Sine  "y = Sine(x,A,w)"
  <strong>extends</strong> Integrand;
  <strong>input</strong> Real A;
  <strong>input</strong> Real w;
<strong>algorithm</strong>
  y:=A*Modelica.Math.sin(w*x);
<strong>end</strong> Sine;

//Call with function partial application as named input argument:
area  := area + quadrature(0, 1, integrand = <strong>function</strong> Sine(A=2, w=i*time));
</pre></blockquote>
<p>Example showing that function types are matching after removing
the bound arguments A and w in a function partial application:</p>
<blockquote>
<pre>
<strong>function</strong> Sine2  "y = Sine2(A,w,x)"
  <strong>input</strong> Real A;
  <strong>input</strong> Real w;
  <strong>input</strong> Real x; // Note: x is now last in argument list.
  <strong>output</strong> Real y;
<strong>algorithm</strong>
  y:=A*Modelica.Math.sin(w*x);
<strong>end</strong> Sine2;

// The partially evaluated Sine2 has only one argument:
// x - and is thus type compatible with Integrand.
area = quadrature(0, 1, integrand = <strong>function</strong> Sine2(A=2, w=3));
</pre></blockquote>
<p>Example of a function partial application of a function that is
a component, according to case (d) above:</p>
<blockquote>
<pre>
<strong>partial function</strong> SurfaceIntegrand
   <strong>input</strong> Real x;
   <strong>input</strong> Real y;
   <strong>output</strong> Real z;
<strong>end</strong> SurfaceIntegrand;

<strong>function</strong> quadratureOnce
  <strong>input</strong> Real x;
  <strong>input</strong> Real y1;
  <strong>input</strong> Real y2;
  <strong>input</strong> SurfaceIntegrand integrand;
  <strong>output</strong> Real z;
<strong>algorithm</strong>
  // This is according to case (d) and needs to bind the 2nd argument
  z := quadrature(y1, y2, <strong>function</strong> integrand(y=x));
<strong>end</strong> quadratureOnce;

<strong>function</strong> surfaceQuadrature
  <strong>input</strong> Real x1;
  <strong>input</strong> Real x2;
  <strong>input</strong> Real y1;
  <strong>input</strong> Real y2;
  <strong>input</strong> SurfaceIntegrand integrand;
  <strong>output</strong> Real integral;
<strong>algorithm</strong>
   // Case (b) and (c)
   integral := quadrature(x1, x2,
     <strong>function</strong> quadratureOnce(y1=y1, y2=y2, integrand=integrand);
<strong>end</strong> surfaceQuadrature;
</pre></blockquote>
<hr/>
Generated at 2020-06-05T21:39:08Z by <a href="http://openmodelica.org">OpenModelica 1.16.0~dev-442-g2e5bc9f</a>
</body>
</html>
