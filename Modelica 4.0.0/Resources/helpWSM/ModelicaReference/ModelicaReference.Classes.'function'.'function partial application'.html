
<html>
<head>
  <meta charset="UTF-8">
  <title>ModelicaReference: Classes.'function'.'function partial application'</title>
  <link rel=stylesheet type=text/css href="resources/documentation.css">
  <script src="resources/jquery.min.js"></script>
  <script src="resources/scripts.js"></script>
</head>
<body>
<div class="wrapper">
<nav>
  <ul class="cf">
    <li><a href="https://www.wolfram.com/system-modeler/">System Modeler</a></li>
  <li><a href="ModelicaReference.html">ModelicaReference</a></li>
  <li><a href="ModelicaReference.Classes.html">Classes</a></li>
  <li><a href="ModelicaReference.Classes.'function'.html">'function'</a></li>
  <li><a href="ModelicaReference.Classes.'function'.'function partial application'.html">'function partial application'</a></li>
  </ul>
</nav>
<header>
  <table><tr><td>
    <h1>'function partial application'</h1>
    <p>function partial application</p>
  </td><td>
    <div><img width="60" height="60" src="resources/icons/ModelicaReference.Classes.'function'.'function partial application'_60x60.png"></div>
  </td></tr></table>
</header>
<section id="information">
<h1>Information</h1>
<div class="hideable">
<p class="aside">This information is part of the Modelica Standard Library maintained by the Modelica Association.</p>
<p>
A function partial application is a function call with certain
formal parameters bound to expressions. A function partial application
returns a partially evaluated function that is also a function,
with the remaining not bound formal parameters still present in the
same order as in the original function declaration. A function partial
application is specified by the function keyword followed by a function
call to func_name giving named formal parameter associations for the
formal parameters to be bound, e.g.:
</p>

<blockquote><pre>
<strong>function</strong> func_name(..., formal_parameter_name = expr, ...)
</pre></blockquote>

<p>
[<em>Note that the keyword function in a function partial application
differentiates the syntax from a normal function call where some
parameters have been left out, and instead supplied via default values.</em>]
The function created by the function partial application acts as the
original function but with the bound formal input parameters(s) removed,
i.e., they cannot be supplied arguments at function call. The binding
occurs when the partially evaluated function is created. A partially
evaluated function is "function compatible" to the same function where
all bound arguments are removed [<em>thus, for checking function type
compatibility, bound formal parameters are ignored</em>].
</p>

<p>
Example of function partial application as argument, positional argument passing, according to case (b) above:
</p>

<blockquote><pre>
<strong>model</strong> Test
   <strong>parameter</strong> Integer N;
   Real area;
<strong>algorithm</strong>
   area := 0;
   <strong>for</strong> i <strong>in</strong> 1:N <strong>loop</strong>
     area  := area + quadrature(0, 1, <strong>function</strong> Sine(A=2, w=i*time));
   <strong>end for</strong>;
<strong>end</strong> Test;

<strong>function</strong> Sine  "y = Sine(x,A,w)"
  <strong>extends</strong> Integrand;
  <strong>input</strong> Real A;
  <strong>input</strong> Real w;
<strong>algorithm</strong>
  y:=A*Modelica.Math.sin(w*x);
<strong>end</strong> Sine;

//Call with function partial application as named input argument:
area  := area + quadrature(0, 1, integrand = <strong>function</strong> Sine(A=2, w=i*time));
</pre></blockquote>

<p>
Example showing that function types are matching after
removing the bound arguments A and w in a function partial
application:
</p>

<blockquote><pre>
<strong>function</strong> Sine2  "y = Sine2(A,w,x)"
  <strong>input</strong> Real A;
  <strong>input</strong> Real w;
  <strong>input</strong> Real x; // Note: x is now last in argument list.
  <strong>output</strong> Real y;
<strong>algorithm</strong>
  y:=A*Modelica.Math.sin(w*x);
<strong>end</strong> Sine2;

// The partially evaluated Sine2 has only one argument:
// x - and is thus type compatible with Integrand.
area = quadrature(0, 1, integrand = <strong>function</strong> Sine2(A=2, w=3));
</pre></blockquote>

<p>
Example of a function partial application of a function that is
a component, according to case (d) above:
</p>

<blockquote><pre>
<strong>partial function</strong> SurfaceIntegrand
   <strong>input</strong> Real x;
   <strong>input</strong> Real y;
   <strong>output</strong> Real z;
<strong>end</strong> SurfaceIntegrand;

<strong>function</strong> quadratureOnce
  <strong>input</strong> Real x;
  <strong>input</strong> Real y1;
  <strong>input</strong> Real y2;
  <strong>input</strong> SurfaceIntegrand integrand;
  <strong>output</strong> Real z;
<strong>algorithm</strong>
  // This is according to case (d) and needs to bind the 2nd argument
  z := quadrature(y1, y2, <strong>function</strong> integrand(y=x));
<strong>end</strong> quadratureOnce;

<strong>function</strong> surfaceQuadrature
  <strong>input</strong> Real x1;
  <strong>input</strong> Real x2;
  <strong>input</strong> Real y1;
  <strong>input</strong> Real y2;
  <strong>input</strong> SurfaceIntegrand integrand;
  <strong>output</strong> Real integral;
<strong>algorithm</strong>
   // Case (b) and (c)
   integral := quadrature(x1, x2,
     <strong>function</strong> quadratureOnce(y1=y1, y2=y2, integrand=integrand);
<strong>end</strong> surfaceQuadrature;
</pre></blockquote>
</div>
</section>
</div>
</body>
</html>