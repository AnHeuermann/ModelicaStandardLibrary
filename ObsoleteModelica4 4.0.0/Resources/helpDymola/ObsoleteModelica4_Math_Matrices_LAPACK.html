<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>ObsoleteModelica4.Math.Matrices.LAPACK</title>
<meta name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="&quot;Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)&quot;">
<style type="text/css">
*       { font-size: 100%; font-family: Arial, sans-serif; }
.modelica, .modelica * { font-size: 90%; font-family: Courier, monospace; white-space: pre; } /* For the Modelica code (in exported html). */
h4      { font-size: 100%; font-weight: bold; color: green; } 
h3      { font-size: 110%; font-weight: bold; color: green; }
h2      { font-size: 130%; font-weight: bold; color: green; }
address { font-weight: normal; }
td      { padding: 2px; vertical-align: top; }
th      { padding: 2px; vertical-align: top; font-weight: bold; }
table   { border-collapse: collapse; }
table[class^="ModelicaTable"] td { border: 1px solid #808080; }
table[class^="ModelicaTable"] th { border: 1px solid #808080; }
pre, code {font-family: "Courier New", monospace;}
pre {white-space: pre; overflow-x : hidden;}
.ModelicaDescription {font-weight: bold;} /* For the description string of the class. */
.ModelicaBaseClass {} /* For the list of base-classes at the of the description. */
.ModelicaKeyword { color: blue; font-weight: normal; font-style: normal; } /* Keywords in Modelica. */
.ModelicaComment { color: #006400;  font-weight: normal; font-style: normal;} /* All three variants of comments in Modelica.  */
.ModelicaString { color: #006400;  font-weight: normal; font-style: normal;} /* String constants. */
.ModelicaClass { color: red; font-weight: normal; font-style: normal;} /* Formatting the names of referenced classes (for base-class and components). */
.ModelicaFunction { color: red; font-weight: normal; font-style: normal;} /* Formatting for called functions. */
.ModelicaTablePackageContent { } /* The table of contents for each package. */
.ModelicaTableCrossReference { } /* The optional cross-reference table. */
.ModelicaTableInputs {} /* The table of inputs for a function. */
.ModelicaTableOutputs {} /* The table of outputs for a function. */
.ModelicaTableParameters {} /* The table of parameters for a model/block. */
.ModelicaTableConnectors {} /* The table of connectors for a model/block. */
.ModelicaTableContents {} /* The table of contents for a connector. */
.ModelicaStartAttribute { font-weight: bold; } /* The formatting used for start-attribute in the table of parameters, to separate them from parameter values. */
.ModelicaParameterTab { background-color: #c0c0c0; font-weight: bold; } /* The tab-heading in the table of parameters */
.ModelicaParameterGroup { background-color: #e0e0e0; } /* The group-heading in the table of parameters */
</style>
</head>
<body>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE LAPACK<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="ObsoleteModelica4.Math.Matrices.LAPACK"></a><a href="ObsoleteModelica4_Math_Matrices.html#ObsoleteModelica4.Math.Matrices"
>ObsoleteModelica4.Math.Matrices</a>.LAPACK</h2>
<p>
<span class="ModelicaDescription">Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)</span><br>
</p>
<h3>Information</h3>
<p><span class="ModelicaBaseClass">Extends from <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons_FunctionsPackage.html#Modelica.Icons.FunctionsPackage"
>Modelica.Icons.FunctionsPackage</a> (Icon for packages containing functions).</span></p>
<h3>Package Content</h3>
<table summary="Package Content" class="ModelicaTablePackageContent">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td><img src="ObsoleteModelica4.Math.Ma8949042cf31d34f5dgegvS.png" alt="ObsoleteModelica4.Math.Matrices.LAPACK.dgegv" width="20" height="20" align="top">&nbsp;<a href="ObsoleteModelica4_Math_Matrices_LAPACK.html#ObsoleteModelica4.Math.Matrices.LAPACK.dgegv"
>dgegv</a>
</td>
<td>Obsolete function. Use Modelica.Math.Matrices.LAPACK.dggev instead</td>
</tr>
<tr>
<td><img src="ObsoleteModelica4.Math.Ma8949042cf31d34f5dgegvS.png" alt="ObsoleteModelica4.Math.Matrices.LAPACK.dgelsx" width="20" height="20" align="top">&nbsp;<a href="ObsoleteModelica4_Math_Matrices_LAPACK.html#ObsoleteModelica4.Math.Matrices.LAPACK.dgelsx"
>dgelsx</a>
</td>
<td>Obsolete function. Use Modelica.Math.Matrices.LAPACK.dgelsy instead</td>
</tr>
<tr>
<td><img src="ObsoleteModelica4.Math.Ma8949042cf31d34f5dgegvS.png" alt="ObsoleteModelica4.Math.Matrices.LAPACK.dgelsx_vec" width="20" height="20" align="top">&nbsp;<a href="ObsoleteModelica4_Math_Matrices_LAPACK.html#ObsoleteModelica4.Math.Matrices.LAPACK.dgelsx_vec"
>dgelsx_vec</a>
</td>
<td>Obsolete function. Use Modelica.Math.Matrices.LAPACK.dgelsy_vec instead</td>
</tr>
<tr>
<td><img src="ObsoleteModelica4.Math.Ma8949042cf31d34f5dgegvS.png" alt="ObsoleteModelica4.Math.Matrices.LAPACK.dgeqpf" width="20" height="20" align="top">&nbsp;<a href="ObsoleteModelica4_Math_Matrices_LAPACK.html#ObsoleteModelica4.Math.Matrices.LAPACK.dgeqpf"
>dgeqpf</a>
</td>
<td>Obsolete function. Use Modelica.Math.Matrices.LAPACK.dgeqp3 instead</td>
</tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgegv<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ObsoleteModelica4.Math.Ma8949042cf31d34f5dgegvI.png" alt="ObsoleteModelica4.Math.Matrices.LAPACK.dgegv" align="right" style="border: 1px solid" width="80" height="80">
<a name="ObsoleteModelica4.Math.Matrices.LAPACK.dgegv"></a><a href="ObsoleteModelica4_Math_Matrices_LAPACK.html#ObsoleteModelica4.Math.Matrices.LAPACK"
>ObsoleteModelica4.Math.Matrices.LAPACK</a>.dgegv</h2>
<p>
<span class="ModelicaDescription">Obsolete function. Use Modelica.Math.Matrices.LAPACK.dggev instead</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    This routine is deprecated and has been replaced by routine DGGEV.

    DGEGV computes the eigenvalues and, optionally, the left and/or right
    eigenvectors of a real matrix pair (A,B).
    Given two square matrices A and B,
    the generalized nonsymmetric eigenvalue problem (GNEP) is to find the
    eigenvalues lambda and corresponding (non-zero) eigenvectors x such
    that

       A*x = lambda*B*x.

    An alternate form is to find the eigenvalues mu and corresponding
    eigenvectors y such that

       mu*A*y = B*y.

    These two forms are equivalent with mu = 1/lambda and x = y if
    neither lambda nor mu is zero.  In order to deal with the case that
    lambda or mu is zero or small, two values alpha and beta are returned
    for each eigenvalue, such that lambda = alpha/beta and
    mu = beta/alpha.

    The vectors x and y in the above equations are right eigenvectors of
    the matrix pair (A,B).  Vectors u and v satisfying

       u**H*A = lambda*u**H*B  or  mu*v**H*A = v**H*B

    are left eigenvectors of (A,B).

    Note: this routine performs &quot;full balancing&quot; on A and B -- see
    &quot;Further Details&quot;, below.

    Arguments
    =========

    JOBVL   (input) CHARACTER*1
            = &#39;N&#39;:  do not compute the left generalized eigenvectors;
            = &#39;V&#39;:  compute the left generalized eigenvectors (returned
                    in VL).

    JOBVR   (input) CHARACTER*1
            = &#39;N&#39;:  do not compute the right generalized eigenvectors;
            = &#39;V&#39;:  compute the right generalized eigenvectors (returned
                    in VR).

    N       (input) INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the matrix A.
            If JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;, then on exit A
            contains the real Schur form of A from the generalized Schur
            factorization of the pair (A,B) after balancing.
            If no eigenvectors were computed, then only the diagonal
            blocks from the Schur form will be correct.  See DGGHRD and
            DHGEQZ for details.

    LDA     (input) INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the matrix B.
            If JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;, then on exit B contains the
            upper triangular matrix obtained from B in the generalized
            Schur factorization of the pair (A,B) after balancing.
            If no eigenvectors were computed, then only those elements of
            B corresponding to the diagonal blocks from the Schur form of
            A will be correct.  See DGGHRD and DHGEQZ for details.

    LDB     (input) INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).

    ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
            The real parts of each scalar alpha defining an eigenvalue of
            GNEP.

    ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
            The imaginary parts of each scalar alpha defining an
            eigenvalue of GNEP.  If ALPHAI(j) is zero, then the j-th
            eigenvalue is real; if positive, then the j-th and
            (j+1)-st eigenvalues are a complex conjugate pair, with
            ALPHAI(j+1) = -ALPHAI(j).

    BETA    (output) DOUBLE PRECISION array, dimension (N)
            The scalars beta that define the eigenvalues of GNEP.

            Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
            beta = BETA(j) represent the j-th eigenvalue of the matrix
            pair (A,B), in one of the forms lambda = alpha/beta or
            mu = beta/alpha.  Since either lambda or mu may overflow,
            they should not, in general, be computed.

    VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored
            in the columns of VL, in the same order as their eigenvalues.
            If the j-th eigenvalue is real, then u(j) = VL(:,j).
            If the j-th and (j+1)-st eigenvalues form a complex conjugate
            pair, then
               u(j) = VL(:,j) + i*VL(:,j+1)
            and
              u(j+1) = VL(:,j) - i*VL(:,j+1).

            Each eigenvector is scaled so that its largest component has
            abs(real part) + abs(imag. part) = 1, except for eigenvectors
            corresponding to an eigenvalue with alpha = beta = 0, which
            are set to zero.
            Not referenced if JOBVL = &#39;N&#39;.

    LDVL    (input) INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = &#39;V&#39;, LDVL &gt;= N.

    VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = &#39;V&#39;, the right eigenvectors x(j) are stored
            in the columns of VR, in the same order as their eigenvalues.
            If the j-th eigenvalue is real, then x(j) = VR(:,j).
            If the j-th and (j+1)-st eigenvalues form a complex conjugate
            pair, then
              x(j) = VR(:,j) + i*VR(:,j+1)
            and
              x(j+1) = VR(:,j) - i*VR(:,j+1).

            Each eigenvector is scaled so that its largest component has
            abs(real part) + abs(imag. part) = 1, except for eigenvalues
            corresponding to an eigenvalue with alpha = beta = 0, which
            are set to zero.
            Not referenced if JOBVR = &#39;N&#39;.

    LDVR    (input) INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = &#39;V&#39;, LDVR &gt;= N.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK &gt;= max(1,8*N).
            For good performance, LWORK must generally be larger.
            To compute the optimal value of LWORK, call ILAENV to get
            blocksizes (for DGEQRF, DORMQR, and DORGQR.)  Then compute:
            NB  -- MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR;
            The optimal LWORK is:
                2*N + MAX( 6*N, N*(NB+1) ).

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                  should be correct for j=INFO+1,...,N.
            &gt; N:  errors that usually indicate LAPACK problems:
                  =N+1: error return from DGGBAL
                  =N+2: error return from DGEQRF
                  =N+3: error return from DORMQR
                  =N+4: error return from DORGQR
                  =N+5: error return from DGGHRD
                  =N+6: error return from DHGEQZ (other than failed
                                                  iteration)
                  =N+7: error return from DTGEVC
                  =N+8: error return from DGGBAK (computing VL)
                  =N+9: error return from DGGBAK (computing VR)
                  =N+10: error return from DLASCL (various calls)

    Further Details
    ===============

    Balancing
    ---------

    This driver calls DGGBAL to both permute and scale rows and columns
    of A and B.  The permutations PL and PR are chosen so that PL*A*PR
    and PL*B*R will be upper triangular except for the diagonal blocks
    A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
    possible.  The diagonal scaling matrices DL and DR are chosen so
    that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
    one (except for the elements that start out zero.)

    After the eigenvalues and eigenvectors of the balanced matrices
    have been computed, DGGBAK transforms the eigenvectors back to what
    they would have been (in perfect arithmetic) if they had not been
    balanced.

    Contents of A and B on Exit
    -------- -- - --- - -- ----

    If any eigenvectors are computed (either JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39; or
    both), then on exit the arrays A and B will contain the real Schur
    form[*] of the &quot;balanced&quot; versions of A and B.  If no eigenvectors
    are computed, then only the diagonal blocks will be correct.

    [*] See DHGEQZ, DGEGS, or read the book &quot;Matrix Computations&quot;,
        by Golub &amp; van Loan, pub. by Johns Hopkins U. Press.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions), <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons.html#Modelica.Icons.ObsoleteModel"
>Modelica.Icons.ObsoleteModel</a> (Icon for classes that are obsolete and will be removed in later versions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgelsx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ObsoleteModelica4.Math.Ma8949042cf31d34f5dgegvI.png" alt="ObsoleteModelica4.Math.Matrices.LAPACK.dgelsx" align="right" style="border: 1px solid" width="80" height="80">
<a name="ObsoleteModelica4.Math.Matrices.LAPACK.dgelsx"></a><a href="ObsoleteModelica4_Math_Matrices_LAPACK.html#ObsoleteModelica4.Math.Matrices.LAPACK"
>ObsoleteModelica4.Math.Matrices.LAPACK</a>.dgelsx</h2>
<p>
<span class="ModelicaDescription">Obsolete function. Use Modelica.Math.Matrices.LAPACK.dgelsy instead</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    This routine is deprecated and has been replaced by routine DGELSY.

    DGELSX computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z&#39; [ inv(T11)*Q1&#39;*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.
            If m &gt;= n and RANK = n, the residual sum-of-squares for
            the solution in the i-th column is given by the sum of
            squares of elements N+1:M in that column.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is an
            initial column, otherwise it is a free column.  Before
            the QR factorization of A, all initial columns are
            permuted to the leading positions; only the remaining
            free columns are moved as a result of column pivoting
            during the factorization.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number &lt; 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace) DOUBLE PRECISION array, dimension
                        (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions), <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons.html#Modelica.Icons.ObsoleteModel"
>Modelica.Icons.ObsoleteModel</a> (Icon for classes that are obsolete and will be removed in later versions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), :]</td><td>&nbsp;</td></tr>
<tr><td>rcond</td><td>Reciprocal condition number to estimate rank</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[max(size(A, 1), size(A, 2)), size(B, 2)]</td><td>Solution is in first size(A,2) rows</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>rank</td><td>Effective rank of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgelsx_vec<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ObsoleteModelica4.Math.Ma8949042cf31d34f5dgegvI.png" alt="ObsoleteModelica4.Math.Matrices.LAPACK.dgelsx_vec" align="right" style="border: 1px solid" width="80" height="80">
<a name="ObsoleteModelica4.Math.Matrices.LAPACK.dgelsx_vec"></a><a href="ObsoleteModelica4_Math_Matrices_LAPACK.html#ObsoleteModelica4.Math.Matrices.LAPACK"
>ObsoleteModelica4.Math.Matrices.LAPACK</a>.dgelsx_vec</h2>
<p>
<span class="ModelicaDescription">Obsolete function. Use Modelica.Math.Matrices.LAPACK.dgelsy_vec instead</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    This routine is deprecated and has been replaced by routine DGELSY.

    DGELSX computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z&#39; [ inv(T11)*Q1&#39;*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N &gt;= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS &gt;= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.
            If m &gt;= n and RANK = n, the residual sum-of-squares for
            the solution in the i-th column is given by the sum of
            squares of elements N+1:M in that column.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB &gt;= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is an
            initial column, otherwise it is a free column.  Before
            the QR factorization of A, all initial columns are
            permuted to the leading positions; only the remaining
            free columns are moved as a result of column pivoting
            during the factorization.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number &lt; 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace) DOUBLE PRECISION array, dimension
                        (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions), <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons.html#Modelica.Icons.ObsoleteModel"
>Modelica.Icons.ObsoleteModel</a> (Icon for classes that are obsolete and will be removed in later versions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>b[size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>rcond</td><td>Reciprocal condition number to estimate rank</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[max(size(A, 1), size(A, 2))]</td><td>solution is in first size(A,2) rows</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>rank</td><td>Effective rank of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeqpf<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ObsoleteModelica4.Math.Ma8949042cf31d34f5dgegvI.png" alt="ObsoleteModelica4.Math.Matrices.LAPACK.dgeqpf" align="right" style="border: 1px solid" width="80" height="80">
<a name="ObsoleteModelica4.Math.Matrices.LAPACK.dgeqpf"></a><a href="ObsoleteModelica4_Math_Matrices_LAPACK.html#ObsoleteModelica4.Math.Matrices.LAPACK"
>ObsoleteModelica4.Math.Matrices.LAPACK</a>.dgeqpf</h2>
<p>
<span class="ModelicaDescription">Obsolete function. Use Modelica.Math.Matrices.LAPACK.dgeqp3 instead</span>
</p>
<h3>Information</h3>
<pre>Lapack documentation
    Purpose
    =======

    This routine is deprecated and has been replaced by routine DGEQP3.

    DGEQPF computes a QR factorization with column pivoting of a
    real M-by-N matrix A: A*P = Q*R.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A. M &gt;= 0.

    N       (input) INTEGER
            The number of columns of the matrix A. N &gt;= 0

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper triangular matrix R; the elements
            below the diagonal, together with the array TAU,
            represent the orthogonal matrix Q as a product of
            min(m,n) elementary reflectors.

    LDA     (input) INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,M).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.

    TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.

    WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)

    INFO    (output) INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value

    Further Details
    ===============

    The matrix Q is represented as a product of elementary reflectors

       Q = H(1) H(2) . . . H(n)

    Each H(i) has the form

       H = I - tau * v * v&#39;

    where tau is a real scalar, and v is a real vector with
    v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).

    The matrix P is represented in jpvt as follows: If
       jpvt(j) = i
    then the jth column of P is the ith canonical unit vector.
</pre>
<p><span class="ModelicaBaseClass">Extends from <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</a> (Icon for functions), <a href="../../../Modelica 4.0.0/Resources/helpDymola/Modelica_Icons.html#Modelica.Icons.ObsoleteModel"
>Modelica.Icons.ObsoleteModel</a> (Icon for classes that are obsolete and will be removed in later versions).</span></p>
<h3>Inputs</h3>
<table summary="Inputs" class="ModelicaTableInputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Square or rectangular matrix</td></tr>
</table>
<h3>Outputs</h3>
<table summary="Outputs" class="ModelicaTableOutputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>QR[size(A, 1), size(A, 2)]</td><td>QR factorization in packed format</td></tr>
<tr><td>tau[min(size(A, 1), size(A, 2))]</td><td>The scalar factors of the elementary reflectors of Q</td></tr>
<tr><td>p[size(A, 2)]</td><td>Pivot vector</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<address>
<a href="http://www.3ds.com/">Automatically generated</a> Fri Oct  2 13:07:25 2020.
</address>
</body>
</html>
